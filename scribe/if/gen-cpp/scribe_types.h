/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef scribe_TYPES_H
#define scribe_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}


namespace Tleveldb {

enum ResultCode {
  OK = 0,
  TRY_LATER = 1,
  ERROR_DECOMPRESS = 2
};

extern const std::map<int, const char*> _ResultCode_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _ResultCode_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift {
template<>
inline constexpr  ::Trocksdb::ResultCode TEnumTraits< ::Trocksdb::ResultCode>::min() {
return  ::Trocksdb::ResultCode::OK;
}
template<>
inline constexpr  ::Trocksdb::ResultCode TEnumTraits< ::Trocksdb::ResultCode>::max() {
return  ::Trocksdb::ResultCode::ERROR_DECOMPRESS;
}
}} // apache:thrift

namespace Tleveldb {
class SourceInfo {
 public:

  static const uint64_t _reflection_id = 16557823557777806572U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  SourceInfo() : host(""), port(0), timestamp(0) {
  }

  SourceInfo(const SourceInfo&) = default;
  SourceInfo& operator=(const SourceInfo&) = default;
  SourceInfo(SourceInfo&&) = default;
  SourceInfo& operator=(SourceInfo&&) = default;

  void __clear() {
    host = "";
    port = 0;
    timestamp = 0;
    __isset.__clear();
  }

  virtual ~SourceInfo() throw() {}

  std::string host;
  int32_t port;
  int64_t timestamp;

  struct __isset {
    __isset() { __clear(); }
    void __clear() {
      host = false;
      port = false;
      timestamp = false;
    }
    bool host;
    bool port;
    bool timestamp;
  } __isset;

  bool operator == (const SourceInfo & rhs) const
  {
    if (!(this->host == rhs.host))
      return false;
    if (!(this->port == rhs.port))
      return false;
    if (!(this->timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const SourceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SourceInfo & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class SourceInfo;
void swap(SourceInfo &a, SourceInfo &b);

class LogEntry {
 public:

  static const uint64_t _reflection_id = 15053466696968532300U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  LogEntry() : category(""), message(""), checksum(0), bucket(0) {
  }

  LogEntry(const LogEntry&) = default;
  LogEntry& operator=(const LogEntry&) = default;
  LogEntry(LogEntry&&) = default;
  LogEntry& operator=(LogEntry&&) = default;

  void __clear() {
    category = "";
    message = "";
    metadata.clear();
    checksum = 0;
    source.__clear();
    bucket = 0;
    __isset.__clear();
  }

  virtual ~LogEntry() throw() {}

  std::string category;
  std::string message;
  std::map<std::string, std::string>  metadata;
  int32_t checksum;
  SourceInfo source;
  int32_t bucket;

  struct __isset {
    __isset() { __clear(); }
    void __clear() {
      category = false;
      message = false;
      metadata = false;
      checksum = false;
      source = false;
      bucket = false;
    }
    bool category;
    bool message;
    bool metadata;
    bool checksum;
    bool source;
    bool bucket;
  } __isset;

  bool operator == (const LogEntry & rhs) const
  {
    if (!(this->category == rhs.category))
      return false;
    if (!(this->message == rhs.message))
      return false;
    if (__isset.metadata != rhs.__isset.metadata)
      return false;
    else if (__isset.metadata && !(metadata == rhs.metadata))
      return false;
    if (__isset.checksum != rhs.__isset.checksum)
      return false;
    else if (__isset.checksum && !(checksum == rhs.checksum))
      return false;
    if (__isset.source != rhs.__isset.source)
      return false;
    else if (__isset.source && !(source == rhs.source))
      return false;
    if (__isset.bucket != rhs.__isset.bucket)
      return false;
    else if (__isset.bucket && !(bucket == rhs.bucket))
      return false;
    return true;
  }
  bool operator != (const LogEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LogEntry & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class LogEntry;
void swap(LogEntry &a, LogEntry &b);

class MessageList {
 public:

  static const uint64_t _reflection_id = 5674270912483072844U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  MessageList() {
  }

  MessageList(const MessageList&) = default;
  MessageList& operator=(const MessageList&) = default;
  MessageList(MessageList&&) = default;
  MessageList& operator=(MessageList&&) = default;

  void __clear() {
    messages.clear();
    __isset.__clear();
  }

  virtual ~MessageList() throw() {}

  std::vector<LogEntry>  messages;

  struct __isset {
    __isset() { __clear(); }
    void __clear() {
      messages = false;
    }
    bool messages;
  } __isset;

  bool operator == (const MessageList & rhs) const
  {
    if (!(this->messages == rhs.messages))
      return false;
    return true;
  }
  bool operator != (const MessageList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MessageList & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class MessageList;
void swap(MessageList &a, MessageList &b);

} // namespace

#endif
