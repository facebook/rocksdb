/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef leveldb_TYPES_H
#define leveldb_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>

namespace apache { namespace thrift { namespace reflection {
class Schema;
}}}


namespace Tleveldb {

enum CompressionType {
  kNoCompression = 0,
  kSnappyCompression = 1
};

extern const std::map<int, const char*> _CompressionType_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _CompressionType_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Trocksdb::CompressionType TEnumTraits< ::Trocksdb::CompressionType>::min() {
return  ::Trocksdb::CompressionType::kNoCompression;
}
template<>
inline constexpr  ::Trocksdb::CompressionType TEnumTraits< ::Trocksdb::CompressionType>::max() {
return  ::Trocksdb::CompressionType::kSnappyCompression;
}
}} // apache:thrift

namespace Tleveldb {
enum Code {
  kOk = 0,
  kNotFound = 1,
  kCorruption = 2,
  kNotSupported = 3,
  kInvalidArgument = 4,
  kIOError = 5,
  kEnd = 6
};

extern const std::map<int, const char*> _Code_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _Code_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Trocksdb::Code TEnumTraits< ::Trocksdb::Code>::min() {
return  ::Trocksdb::Code::kOk;
}
template<>
inline constexpr  ::Trocksdb::Code TEnumTraits< ::Trocksdb::Code>::max() {
return  ::Trocksdb::Code::kEnd;
}
}} // apache:thrift

namespace Tleveldb {
enum IteratorType {
  seekToFirst = 0,
  seekToLast = 1,
  seekToKey = 2
};

extern const std::map<int, const char*> _IteratorType_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _IteratorType_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Trocksdb::IteratorType TEnumTraits< ::Trocksdb::IteratorType>::min() {
return  ::Trocksdb::IteratorType::seekToFirst;
}
template<>
inline constexpr  ::Trocksdb::IteratorType TEnumTraits< ::Trocksdb::IteratorType>::max() {
return  ::Trocksdb::IteratorType::seekToKey;
}
}} // apache:thrift

namespace Tleveldb {
enum AssocVisibility {
  VISIBLE = 0,
  DELETED = 1,
  UNUSED1 = 2,
  HIDDEN = 3,
  UNUSED2 = 4,
  HARD_DELETE = 4
};

extern const std::map<int, const char*> _AssocVisibility_VALUES_TO_NAMES;

extern const std::map<const char*, int, apache::thrift::ltstr> _AssocVisibility_NAMES_TO_VALUES;

} // namespace
namespace apache { namespace thrift { 
template<>
inline constexpr  ::Trocksdb::AssocVisibility TEnumTraits< ::Trocksdb::AssocVisibility>::min() {
return  ::Trocksdb::AssocVisibility::VISIBLE;
}
template<>
inline constexpr  ::Trocksdb::AssocVisibility TEnumTraits< ::Trocksdb::AssocVisibility>::max() {
return  ::Trocksdb::AssocVisibility::HARD_DELETE;
}
}} // apache:thrift

namespace Tleveldb {
typedef std::string Text;

typedef std::string Bytes;

class Slice {
 public:

  static const uint64_t _reflection_id = 2199896239461470156U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Slice() : data(""), size(0) {
  }

  Slice(const Slice&) = default;
  Slice& operator=(const Slice&) = default;
  Slice(Slice&&) = default;
  Slice& operator=(Slice&&) = default;

  void __clear() {
    data = "";
    size = 0;
    __isset.__clear();
  }

  virtual ~Slice() throw() {}

  Text data;
  int32_t size;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      data = false;
      size = false;
    }
    bool data;
    bool size;
  } __isset;

  bool operator == (const Slice & rhs) const
  {
    if (!(this->data == rhs.data))
      return false;
    if (!(this->size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const Slice &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Slice & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Slice;
void swap(Slice &a, Slice &b);

class Range {
 public:

  static const uint64_t _reflection_id = 6170219570187881516U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Range() {
  }

  Range(const Range&) = default;
  Range& operator=(const Range&) = default;
  Range(Range&&) = default;
  Range& operator=(Range&&) = default;

  void __clear() {
    start.__clear();
    limit.__clear();
    __isset.__clear();
  }

  virtual ~Range() throw() {}

  Slice start;
  Slice limit;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      start = false;
      limit = false;
    }
    bool start;
    bool limit;
  } __isset;

  bool operator == (const Range & rhs) const
  {
    if (!(this->start == rhs.start))
      return false;
    if (!(this->limit == rhs.limit))
      return false;
    return true;
  }
  bool operator != (const Range &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Range & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Range;
void swap(Range &a, Range &b);

class DBOptions {
 public:

  static const uint64_t _reflection_id = 6731746507948871532U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  DBOptions() : create_if_missing(0), error_if_exists(0), write_buffer_size(0), max_open_files(0), block_size(0), block_restart_interval(0), compression(static_cast<CompressionType>(0)), num_levels(0), level0_file_num_compaction_trigger(0), level0_slowdown_writes_trigger(0), level0_stop_writes_trigger(0), target_file_size_base(0), target_file_size_multiplier(0), max_bytes_for_level_base(0), max_bytes_for_level_multiplier(0), max_grandparent_overlap_factor(0), disableDataSync(0) {
  }

  DBOptions(const DBOptions&) = default;
  DBOptions& operator=(const DBOptions&) = default;
  DBOptions(DBOptions&&) = default;
  DBOptions& operator=(DBOptions&&) = default;

  void __clear() {
    create_if_missing = 0;
    error_if_exists = 0;
    write_buffer_size = 0;
    max_open_files = 0;
    block_size = 0;
    block_restart_interval = 0;
    compression = static_cast<CompressionType>(0);
    num_levels = 0;
    level0_file_num_compaction_trigger = 0;
    level0_slowdown_writes_trigger = 0;
    level0_stop_writes_trigger = 0;
    target_file_size_base = 0;
    target_file_size_multiplier = 0;
    max_bytes_for_level_base = 0;
    max_bytes_for_level_multiplier = 0;
    max_grandparent_overlap_factor = 0;
    disableDataSync = 0;
    __isset.__clear();
  }

  virtual ~DBOptions() throw() {}

  bool create_if_missing;
  bool error_if_exists;
  int32_t write_buffer_size;
  int32_t max_open_files;
  int32_t block_size;
  int32_t block_restart_interval;
  CompressionType compression;
  int32_t num_levels;
  int32_t level0_file_num_compaction_trigger;
  int32_t level0_slowdown_writes_trigger;
  int32_t level0_stop_writes_trigger;
  int32_t target_file_size_base;
  int32_t target_file_size_multiplier;
  int32_t max_bytes_for_level_base;
  int32_t max_bytes_for_level_multiplier;
  int32_t max_grandparent_overlap_factor;
  bool disableDataSync;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      create_if_missing = false;
      error_if_exists = false;
      write_buffer_size = false;
      max_open_files = false;
      block_size = false;
      block_restart_interval = false;
      compression = false;
      num_levels = false;
      level0_file_num_compaction_trigger = false;
      level0_slowdown_writes_trigger = false;
      level0_stop_writes_trigger = false;
      target_file_size_base = false;
      target_file_size_multiplier = false;
      max_bytes_for_level_base = false;
      max_bytes_for_level_multiplier = false;
      max_grandparent_overlap_factor = false;
      disableDataSync = false;
    }
    bool create_if_missing;
    bool error_if_exists;
    bool write_buffer_size;
    bool max_open_files;
    bool block_size;
    bool block_restart_interval;
    bool compression;
    bool num_levels;
    bool level0_file_num_compaction_trigger;
    bool level0_slowdown_writes_trigger;
    bool level0_stop_writes_trigger;
    bool target_file_size_base;
    bool target_file_size_multiplier;
    bool max_bytes_for_level_base;
    bool max_bytes_for_level_multiplier;
    bool max_grandparent_overlap_factor;
    bool disableDataSync;
  } __isset;

  bool operator == (const DBOptions & rhs) const
  {
    if (!(this->create_if_missing == rhs.create_if_missing))
      return false;
    if (!(this->error_if_exists == rhs.error_if_exists))
      return false;
    if (!(this->write_buffer_size == rhs.write_buffer_size))
      return false;
    if (!(this->max_open_files == rhs.max_open_files))
      return false;
    if (!(this->block_size == rhs.block_size))
      return false;
    if (!(this->block_restart_interval == rhs.block_restart_interval))
      return false;
    if (!(this->compression == rhs.compression))
      return false;
    if (!(this->num_levels == rhs.num_levels))
      return false;
    if (!(this->level0_file_num_compaction_trigger == rhs.level0_file_num_compaction_trigger))
      return false;
    if (!(this->level0_slowdown_writes_trigger == rhs.level0_slowdown_writes_trigger))
      return false;
    if (!(this->level0_stop_writes_trigger == rhs.level0_stop_writes_trigger))
      return false;
    if (!(this->target_file_size_base == rhs.target_file_size_base))
      return false;
    if (!(this->target_file_size_multiplier == rhs.target_file_size_multiplier))
      return false;
    if (!(this->max_bytes_for_level_base == rhs.max_bytes_for_level_base))
      return false;
    if (!(this->max_bytes_for_level_multiplier == rhs.max_bytes_for_level_multiplier))
      return false;
    if (!(this->max_grandparent_overlap_factor == rhs.max_grandparent_overlap_factor))
      return false;
    if (!(this->disableDataSync == rhs.disableDataSync))
      return false;
    return true;
  }
  bool operator != (const DBOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBOptions & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class DBOptions;
void swap(DBOptions &a, DBOptions &b);

class WriteOptions {
 public:

  static const uint64_t _reflection_id = 8830325115029814540U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  WriteOptions() : sync(0), disableWAL(0) {
  }

  WriteOptions(const WriteOptions&) = default;
  WriteOptions& operator=(const WriteOptions&) = default;
  WriteOptions(WriteOptions&&) = default;
  WriteOptions& operator=(WriteOptions&&) = default;

  void __clear() {
    sync = 0;
    disableWAL = 0;
    __isset.__clear();
  }

  virtual ~WriteOptions() throw() {}

  bool sync;
  bool disableWAL;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      sync = false;
      disableWAL = false;
    }
    bool sync;
    bool disableWAL;
  } __isset;

  bool operator == (const WriteOptions & rhs) const
  {
    if (!(this->sync == rhs.sync))
      return false;
    if (!(this->disableWAL == rhs.disableWAL))
      return false;
    return true;
  }
  bool operator != (const WriteOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WriteOptions & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class WriteOptions;
void swap(WriteOptions &a, WriteOptions &b);

class Snapshot {
 public:

  static const uint64_t _reflection_id = 15670548806217660204U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Snapshot() : snapshotid(0) {
  }

  Snapshot(const Snapshot&) = default;
  Snapshot& operator=(const Snapshot&) = default;
  Snapshot(Snapshot&&) = default;
  Snapshot& operator=(Snapshot&&) = default;

  void __clear() {
    snapshotid = 0;
    __isset.__clear();
  }

  virtual ~Snapshot() throw() {}

  int64_t snapshotid;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      snapshotid = false;
    }
    bool snapshotid;
  } __isset;

  bool operator == (const Snapshot & rhs) const
  {
    if (!(this->snapshotid == rhs.snapshotid))
      return false;
    return true;
  }
  bool operator != (const Snapshot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Snapshot & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Snapshot;
void swap(Snapshot &a, Snapshot &b);

class ReadOptions {
 public:

  static const uint64_t _reflection_id = 1092669993626789804U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ReadOptions() : verify_checksums(0), fill_cache(0) {
  }

  ReadOptions(const ReadOptions&) = default;
  ReadOptions& operator=(const ReadOptions&) = default;
  ReadOptions(ReadOptions&&) = default;
  ReadOptions& operator=(ReadOptions&&) = default;

  void __clear() {
    verify_checksums = 0;
    fill_cache = 0;
    snapshot.__clear();
    __isset.__clear();
  }

  virtual ~ReadOptions() throw() {}

  bool verify_checksums;
  bool fill_cache;
  Snapshot snapshot;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      verify_checksums = false;
      fill_cache = false;
      snapshot = false;
    }
    bool verify_checksums;
    bool fill_cache;
    bool snapshot;
  } __isset;

  bool operator == (const ReadOptions & rhs) const
  {
    if (!(this->verify_checksums == rhs.verify_checksums))
      return false;
    if (!(this->fill_cache == rhs.fill_cache))
      return false;
    if (!(this->snapshot == rhs.snapshot))
      return false;
    return true;
  }
  bool operator != (const ReadOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReadOptions & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ReadOptions;
void swap(ReadOptions &a, ReadOptions &b);

class DBHandle {
 public:

  static const uint64_t _reflection_id = 8973827971994157004U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  DBHandle() : dbname("") {
  }

  DBHandle(const DBHandle&) = default;
  DBHandle& operator=(const DBHandle&) = default;
  DBHandle(DBHandle&&) = default;
  DBHandle& operator=(DBHandle&&) = default;

  void __clear() {
    dbname = "";
    __isset.__clear();
  }

  virtual ~DBHandle() throw() {}

  Text dbname;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      dbname = false;
    }
    bool dbname;
  } __isset;

  bool operator == (const DBHandle & rhs) const
  {
    if (!(this->dbname == rhs.dbname))
      return false;
    return true;
  }
  bool operator != (const DBHandle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBHandle & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class DBHandle;
void swap(DBHandle &a, DBHandle &b);

class Iterator {
 public:

  static const uint64_t _reflection_id = 11184146435197093740U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  Iterator() : iteratorid(0) {
  }

  Iterator(const Iterator&) = default;
  Iterator& operator=(const Iterator&) = default;
  Iterator(Iterator&&) = default;
  Iterator& operator=(Iterator&&) = default;

  void __clear() {
    iteratorid = 0;
    __isset.__clear();
  }

  virtual ~Iterator() throw() {}

  int64_t iteratorid;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      iteratorid = false;
    }
    bool iteratorid;
  } __isset;

  bool operator == (const Iterator & rhs) const
  {
    if (!(this->iteratorid == rhs.iteratorid))
      return false;
    return true;
  }
  bool operator != (const Iterator &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Iterator & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class Iterator;
void swap(Iterator &a, Iterator &b);

class kv {
 public:

  static const uint64_t _reflection_id = 16082992224095104076U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  kv() {
  }

  kv(const kv&) = default;
  kv& operator=(const kv&) = default;
  kv(kv&&) = default;
  kv& operator=(kv&&) = default;

  void __clear() {
    key.__clear();
    value.__clear();
    __isset.__clear();
  }

  virtual ~kv() throw() {}

  Slice key;
  Slice value;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      key = false;
      value = false;
    }
    bool key;
    bool value;
  } __isset;

  bool operator == (const kv & rhs) const
  {
    if (!(this->key == rhs.key))
      return false;
    if (!(this->value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const kv &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const kv & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class kv;
void swap(kv &a, kv &b);

class ResultItem {
 public:

  static const uint64_t _reflection_id = 13211316281207238796U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultItem() : status(static_cast<Code>(0)) {
  }

  ResultItem(const ResultItem&) = default;
  ResultItem& operator=(const ResultItem&) = default;
  ResultItem(ResultItem&&) = default;
  ResultItem& operator=(ResultItem&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    value.__clear();
    __isset.__clear();
  }

  virtual ~ResultItem() throw() {}

  Code status;
  Slice value;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      value = false;
    }
    bool status;
    bool value;
  } __isset;

  bool operator == (const ResultItem & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ResultItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultItem & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultItem;
void swap(ResultItem &a, ResultItem &b);

class ResultPair {
 public:

  static const uint64_t _reflection_id = 14875242256166808460U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultPair() : status(static_cast<Code>(0)) {
  }

  ResultPair(const ResultPair&) = default;
  ResultPair& operator=(const ResultPair&) = default;
  ResultPair(ResultPair&&) = default;
  ResultPair& operator=(ResultPair&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    keyvalue.__clear();
    __isset.__clear();
  }

  virtual ~ResultPair() throw() {}

  Code status;
  kv keyvalue;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      keyvalue = false;
    }
    bool status;
    bool keyvalue;
  } __isset;

  bool operator == (const ResultPair & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->keyvalue == rhs.keyvalue))
      return false;
    return true;
  }
  bool operator != (const ResultPair &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultPair & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultPair;
void swap(ResultPair &a, ResultPair &b);

class ResultSnapshot {
 public:

  static const uint64_t _reflection_id = 16627180600575569004U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultSnapshot() : status(static_cast<Code>(0)) {
  }

  ResultSnapshot(const ResultSnapshot&) = default;
  ResultSnapshot& operator=(const ResultSnapshot&) = default;
  ResultSnapshot(ResultSnapshot&&) = default;
  ResultSnapshot& operator=(ResultSnapshot&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    snapshot.__clear();
    __isset.__clear();
  }

  virtual ~ResultSnapshot() throw() {}

  Code status;
  Snapshot snapshot;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      snapshot = false;
    }
    bool status;
    bool snapshot;
  } __isset;

  bool operator == (const ResultSnapshot & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->snapshot == rhs.snapshot))
      return false;
    return true;
  }
  bool operator != (const ResultSnapshot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultSnapshot & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultSnapshot;
void swap(ResultSnapshot &a, ResultSnapshot &b);

class ResultIterator {
 public:

  static const uint64_t _reflection_id = 595886977232564460U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  ResultIterator() : status(static_cast<Code>(0)) {
  }

  ResultIterator(const ResultIterator&) = default;
  ResultIterator& operator=(const ResultIterator&) = default;
  ResultIterator(ResultIterator&&) = default;
  ResultIterator& operator=(ResultIterator&&) = default;

  void __clear() {
    status = static_cast<Code>(0);
    iterator.__clear();
    __isset.__clear();
  }

  virtual ~ResultIterator() throw() {}

  Code status;
  Iterator iterator;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      status = false;
      iterator = false;
    }
    bool status;
    bool iterator;
  } __isset;

  bool operator == (const ResultIterator & rhs) const
  {
    if (!(this->status == rhs.status))
      return false;
    if (!(this->iterator == rhs.iterator))
      return false;
    return true;
  }
  bool operator != (const ResultIterator &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ResultIterator & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class ResultIterator;
void swap(ResultIterator &a, ResultIterator &b);

class LeveldbException : public apache::thrift::TException {
 public:

  static const uint64_t _reflection_id = 2551220192341843436U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  LeveldbException() : message(""), errorCode(static_cast<Code>(0)) {
  }

  LeveldbException(const LeveldbException&) = default;
  LeveldbException& operator=(const LeveldbException&) = default;
  LeveldbException(LeveldbException&&) = default;
  LeveldbException& operator=(LeveldbException&&) = default;

  void __clear() {
    message = "";
    errorCode = static_cast<Code>(0);
    __isset.__clear();
  }

  virtual ~LeveldbException() throw() {}

  Text message;
  Code errorCode;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      message = false;
      errorCode = false;
    }
    bool message;
    bool errorCode;
  } __isset;

  bool operator == (const LeveldbException & rhs) const
  {
    if (!(this->message == rhs.message))
      return false;
    if (!(this->errorCode == rhs.errorCode))
      return false;
    return true;
  }
  bool operator != (const LeveldbException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LeveldbException & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  virtual const char* what() const throw() {
    return "LeveldbException";
  }

};

class LeveldbException;
void swap(LeveldbException &a, LeveldbException &b);

class IOError : public apache::thrift::TException {
 public:

  static const uint64_t _reflection_id = 8460881927871070060U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  IOError() : message("") {
  }

  IOError(const IOError&) = default;
  IOError& operator=(const IOError&) = default;
  IOError(IOError&&) = default;
  IOError& operator=(IOError&&) = default;

  void __clear() {
    message = "";
    __isset.__clear();
  }

  virtual ~IOError() throw() {}

  std::string message;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      message = false;
    }
    bool message;
  } __isset;

  bool operator == (const IOError & rhs) const
  {
    if (!(this->message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const IOError &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IOError & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

  virtual const char* what() const throw() {
    return "IOError";
  }

};

class IOError;
void swap(IOError &a, IOError &b);

class TaoAssocGetResult {
 public:

  static const uint64_t _reflection_id = 6301164048086986412U;
  static void _reflection_register(::apache::thrift::reflection::Schema&);
  TaoAssocGetResult() : id2(0), id1Type(0), id2Type(0), time(0), dataVersion(0), data("") {
  }

  TaoAssocGetResult(const TaoAssocGetResult&) = default;
  TaoAssocGetResult& operator=(const TaoAssocGetResult&) = default;
  TaoAssocGetResult(TaoAssocGetResult&&) = default;
  TaoAssocGetResult& operator=(TaoAssocGetResult&&) = default;

  void __clear() {
    id2 = 0;
    id1Type = 0;
    id2Type = 0;
    time = 0;
    dataVersion = 0;
    data = "";
    __isset.__clear();
  }

  virtual ~TaoAssocGetResult() throw() {}

  int64_t id2;
  int64_t id1Type;
  int64_t id2Type;
  int64_t time;
  int64_t dataVersion;
  Text data;

  struct __isset {
    __isset() { __clear(); } 
    void __clear() {
      id2 = false;
      id1Type = false;
      id2Type = false;
      time = false;
      dataVersion = false;
      data = false;
    }
    bool id2;
    bool id1Type;
    bool id2Type;
    bool time;
    bool dataVersion;
    bool data;
  } __isset;

  bool operator == (const TaoAssocGetResult & rhs) const
  {
    if (!(this->id2 == rhs.id2))
      return false;
    if (!(this->id1Type == rhs.id1Type))
      return false;
    if (!(this->id2Type == rhs.id2Type))
      return false;
    if (!(this->time == rhs.time))
      return false;
    if (!(this->dataVersion == rhs.dataVersion))
      return false;
    if (!(this->data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const TaoAssocGetResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaoAssocGetResult & ) const;

  uint32_t read(apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(apache::thrift::protocol::TProtocol* oprot) const;

};

class TaoAssocGetResult;
void swap(TaoAssocGetResult &a, TaoAssocGetResult &b);

} // namespace

#endif
